<html>

<head>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://unpkg.com/scrollama"></script>
</head>
<style>
    section {
        height: 500;
    }

    #graphic {
        margin: auto;
        width: 1500px;
        flex-direction: row;
        align-items: top;
        justify-content: space-around;
    }

    #vis {
        display: inline-block;
        position: fixed;
        top: 0px;
        z-index: 1;
        margin-left: 0;
        height: 1000px;
        width: 1000px;
    }

    .step {
        margin-bottom: 100px;
        height: 700px;
        font-family: "Domine";
        font-weight: 400;
        line-height: 1.4em;
        text-align: justify;
        /* display: flex;
    flex-direction: column;
    justify-content: space-around; */
    }

    #sections {
        position: relative;
        display: inline-block;
        width: 400px;
        top: 60px;
        z-index: 90;
        margin-right: 50px;
    }

    /* #scrolly {
        position: relative;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        background-color: #f3f3f3;
        padding: 1rem;
    }

    #scrolly>* {
        -webkit-box-flex: 1;
        -ms-flex: 1;
        flex: 1;
    }

    article {
        position: relative;
        padding: 0 1rem;
        max-width: 70%;
    }

    .receipt {
        position: sticky;
        width: 100%;
        max-width: 30%;
        margin: 0;
        -webkit-transform: translate3d(0, 0, 0);
        -moz-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);


        background-color: #FAF9F6;
        z-index: 0;

        border-style: solid;
    }

    .receipt h4 {
        text-align: center;
        font-size: 2.5rem;
        color: black;
        margin: 15px;
        margin-bottom: 0px;
    }

    .receipt h5 {
        text-align: center;
        font-size: 2rem;
        font-weight: 500;
        color: black;
        margin: 2px;
    }

    .receipt h6 {
        text-align: center;
        font-size: 1.5rem;
        font-weight: 500;
        color: black;
        margin: 2px;
    }

    .dashed-line {
        margin-top: 20px;
        max-width: 70%;
        border: 2px dashed black;
    }

    .receipt p:first-child {
        margin-top: 30px;
    }


    .receipt p {
        text-align: center;
        color: black;
        font-size: 1.5rem;
        margin: 3px;
    }

    .step {
        margin: 0 auto 2rem auto;
        background-color: #3b3b3b;
        color: #fff;
    }

    .step:last-child {
        margin-bottom: 0;
    }

    .step.is-active {
        background-color: #FAF9F6;
        color: #3b3b3b;
        border-style: solid;
    }

    .step p {
        text-align: center;
        padding: 1rem;
        font-size: 1.5rem;
    }

    .y-axis {
        font-size: 14px;
        font-family: 'Franklin Gothic';
    }

    .x-axis {
        font-size: 12px;
        font-family: 'Franklin Gothic';

    } */
</style>


<!-- <section id="scrolly">

    <div class="receipt">
        <h4> The Cost of Your Filet </h4>
        <h5> From Plate to Sea </h5>
        <h6> Address: blah blah 123 st</h6>
        <h6> Telephone: 879-345-9876 </h6>
        <hr class="dashed-line">
        <p id="water"></p>
        <p id="land"></p>
        <p id="nitrogen"></p>
        <p id="phosphorous"></p>
    </div>

    <article>
        <div class="step water" data-step="1">
            <p> Chart 1 </p>
            <svg id="bar1" height="500" width="600"></svg>
        </div>
        <div class="step land" data-step="2">
            <p> Chart 2 </p>
            <svg id="bar2" height="500" width="600"></svg>
        </div>
        <div class="step nitrogen" data-step="3">
            <p> Chart 3 </p>
        </div>
        <div class="step phosphorous" data-step="4">
            <p> Chart 4 </p>
        </div>
    </article>
</section> -->

<body>
    <div id="graphic">
        <div id="sections">
            <section class="step">Chart1</section>
            <section class="step">Chart2</section>
            <section class="step">Chart3</section>
            <section class="step">Chart4</section>
        </div>
        <div id="vis">
            <svg id="bar1" height="500" width="600"></svg>
        </div>
    </div>

    <svg id="choropleth" height="600" width="900" style="background: #EEEEEE; margin-top:50px">

    </svg>
    <script>

        const map_svg = d3.select("#choropleth");
        const map_width = map_svg.attr("width");
        const map_height = map_svg.attr("height");
        const map_margin = { top: 20, right: 20, bottom: 20, left: 20 };
        const mapWidth = map_width - map_margin.left - map_margin.right;
        const mapHeight = map_height - map_margin.top - map_margin.bottom;
        const map = map_svg.append("g")
            .attr("transform", "translate(" + map_margin.left + "," + map_margin.top + ")");



        const getData = async function () {



            let water_use = await d3.csv("data/freshwater-use-seafood.csv", d3.autotype);
            let land_use = await d3.csv("data/land-use-seafood.csv", d3.autotype);
            let nitrogen_emissions = await d3.csv("data/nitrogen-emissions-seafood.csv", d3.autotype);
            let phos_emissions = await d3.csv("data/phosphorous-emissions-seafood.csv", d3.autotype);

            //TO DO: Code that find what fish has been selected

            // can either be Salmon, Shrimp, or Tilapia
            salmon_water_use = water_use.filter(d => d.Entity === 'Salmon (farmed)')[0]['Freshwater use (m3 / kg edible weight)']
            tilapia_water_use = water_use.filter(d => d.Entity === 'Tilapia (farmed)')[0]['Freshwater use (m3 / kg edible weight)']
            shrimp_water_use = water_use.filter(d => d.Entity === 'Shrimp (farmed)')[0]['Freshwater use (m3 / kg edible weight)']

            salmon_land_use = land_use.filter(d => d.Entity === 'Salmon (farmed)')[0]['Land use (m2 / kg edible weight)']
            tilapia_land_use = land_use.filter(d => d.Entity === 'Tilapia (farmed)')[0]['Land use (m2 / kg edible weight)']
            shrimp_land_use = land_use.filter(d => d.Entity === 'Shrimp (farmed)')[0]['Land use (m2 / kg edible weight)']

            salmon_nitrogen_emissions = nitrogen_emissions.filter(d => d.Entity === 'Salmon (farmed)')[0]['Nitrogen (kgN / t edible weight)']
            tilapia_nitrogen_emissions = nitrogen_emissions.filter(d => d.Entity === 'Tilapia (farmed)')[0]['Nitrogen (kgN / t edible weight)']
            shrimp_nitrogen_emissions = nitrogen_emissions.filter(d => d.Entity === 'Shrimp (farmed)')[0]['Nitrogen (kgN / t edible weight)']

            salmon_phos_emissions = phos_emissions.filter(d => d.Entity === 'Salmon (farmed)')[0]['Phosphorous (kgP / t edible weight)']
            tilapia_phos_emissions = phos_emissions.filter(d => d.Entity === 'Tilapia (farmed)')[0]['Phosphorous (kgP / t edible weight)']
            shrimp_phos_emissions = phos_emissions.filter(d => d.Entity === 'Shrimp (farmed)')[0]['Phosphorous (kgP / t edible weight)']

            console.log('Salmon water use', salmon_water_use)
            console.log('Salmon land use', salmon_land_use)
            console.log('Salmon nitrogen emissions', salmon_nitrogen_emissions)
            console.log('Salmon phosphorous emissions', salmon_phos_emissions)

            const chart1 = d3.select("#bar1");
            const width1 = chart1.attr("width");
            const height1 = chart1.attr("height");
            const margin1 = { top: 35, right: 10, bottom: 45, left: 150 };
            const chartWidth1 = width1 - margin1.left - margin1.right;
            const chartHeight1 = height1 - margin1.top - margin1.bottom;
            let annotations1 = chart1.append("g").attr("id", "annotations");
            const chartArea1 = chart1.append("g").attr("transform", "translate(" + margin1.left + "," + margin1.top + ")");

            createScales();


            // draw default graph, water use
            chartArea1.selectAll('rect.bar').data(water_use)
                .join('rect')
                .attr('class', 'bar')
                // .attr("fill", d => console.log(d['Freshwater use (m3 / kg edible weight)']))
                .attr('x', d => barScale1(0))
                .attr('y', d => leftAxisScale1(d.Entity.split('(')[0].substr(0, d.Entity.split('(')[0].length - 1)))
                .attr("height", leftAxisScale1.bandwidth())
                .attr("width", d => barScale1(Number(d['Freshwater use (m3 / kg edible weight)'])) - barScale1(0))

            function scroller() {
                let container = d3.select('body')
                let dispatch = d3.dispatch('active', 'progress');
                let sections = d3.selectAll('.step')
                let sectionPositions
                let currentIndex = -1
                let containerStart = 0;
                // Binds the position function to the scroll event, and the resize function to the resize event. What these functions do are detailed below. 
                function scroll() {
                    d3.select(window)
                        .on('scroll.scroller', position)
                        .on('resize.scroller', resize)
                    resize();
                    let timer = d3.timer(function () {
                        position();
                        timer.stop();
                    });
                }
                //The resize function determines where each of the .step elements are on the page, relative to the top of the first element. It saves all of the co-ordinates of these elements in an array called sectionPositions
                function resize() {
                    sectionPositions = [];
                    let startPos;
                    sections.each(function (d, i) {
                        let top = this.getBoundingClientRect().top;
                        if (i === 0) {
                            startPos = top;
                        }
                        sectionPositions.push(top - startPos)
                    });
                }
                //The position function determines where the user is on the page (using window.pageYOffset), and uses that to determine which section of text should currently be in view. It then uses D3’s dispatching tools to signal the 'progress' event, which will be used in the main script, passing along the current section index so that the script knows which stage of the animation/visualisation should be showing. 
                function position() {
                    let pos = window.pageYOffset - 300 - containerStart;
                    let sectionIndex = d3.bisect(sectionPositions, pos);
                    sectionIndex = Math.min(sections.size() - 1, sectionIndex);
                    if (currentIndex !== sectionIndex) {
                        dispatch.call('active', this, sectionIndex);
                        currentIndex = sectionIndex;
                    }
                    let prevIndex = Math.max(sectionIndex - 1, 0);
                    let prevTop = sectionPositions[prevIndex]
                    let progress = (pos - prevTop) / (sectionPositions[sectionIndex] - prevTop);
                    dispatch.call('progress', this, currentIndex, progress)
                }
                //The code here adds an event listener to the dispatcher.
                scroll.container = function (value) {
                    if (arguments.legth === 0) {
                        return container
                    }
                    container = value
                    return scroll
                }
                scroll.on = function (action, callback) {
                    dispatch.on(action, callback)
                };
                return scroll;
            }

            let scroll = scroller().container(d3.select('#graphic'))
            scroll()
            let lastIndex, activeIndex = 0
            //This is where most of the magic happens. Every time the user scrolls, we receive a new index. First, we find all the irrelevant sections, and reduce their opacity. 
            scroll.on('active', function (index) {
                d3.selectAll('.step')
                    .transition().duration(500)
                    .style('opacity', function (d, i) { return i === index ? 1 : 0.1; });
                //Next, we selection from a range of activationFunctions (which we create), based on the index of the current section. 
                activeIndex = index
                console.log('active index')
                console.log(activeIndex);
                let sign = (activeIndex - lastIndex) < 0 ? -1 : 1;
                let scrolledSections = d3.range(lastIndex + sign, activeIndex + sign, sign);
                scrolledSections.forEach(i => {
                    console.log('i')
                    console.log(i)
                    activationFunctions[i]();
                })
                lastIndex = activeIndex;
            })
            scroll.on('progress', function (index, progress) {
                if (index == 2 & progress > 0.7) { }
            })
            //I placed all the functions in an array. Each function corresponds to a different change in the visualisation. One may change the graph into a scatter plot, and another may initiate a force simulation.
            let activationFunctions = [redrawDefault,
                drawInitial,
                draw2
                // draw2,
                // draw3,
                // draw4,
                // draw5,
                // draw6,
                // draw7,
                // draw8
            ]


            function redrawDefault() {s
                chartArea1.selectAll('rect.bar').data(water_use)
                    .join(enter => enter.append('rect')
                        .attr('class', 'bar')
                        // .attr("fill", barChartColor(input_mbti))
                        .attr("x", d => barScale1(0))
                        .attr("y", d => leftAxisScale1(d.Entity.split('(')[0].substr(0, d.Entity.split('(')[0].length - 1)))
                        .attr("height", leftAxisScale1.bandwidth())
                        .attr("width", d => barScale1(Number(d['Freshwater use (m3 / kg edible weight)'])) - barScale1(0))
                        .attr("opacity", 0)
                        .call(enter => enter.transition()
                            .attr('opacity', 1)),
                        update => update.call(update => update.transition()
                            // .attr("fill", barChartColor(input_mbti))
                            .attr("x", d => barScale1(0))
                            .attr("y", d => leftAxisScale1(d.Entity.split('(')[0].substr(0, d.Entity.split('(')[0].length - 1)))
                            .attr("height", leftAxisScale1.bandwidth())
                            .attr("width", d => barScale1(Number(d['Freshwater use (m3 / kg edible weight)'])) - barScale1(0))),
                        exit => exit.call(exit => exit.transition().attr('opacity', 0).remove()));
            }
        

        function createScales() {
            // Setting up scales and axes for the 4 bar charts (do we need 4 separate bar charts or should we update the same one?)

            //removing "(farmed)" from each of the fish entities
            species = water_use.map(d => d.Entity.split('(')[0].substr(0, d.Entity.split('(')[0].length - 1))

            //making scales and axes for water
            water_values = water_use.map(d => Number(d['Freshwater use (m3 / kg edible weight)']))
            land_values = land_use.map(d => Number(d['Land use (m2 / kg edible weight)']))
            nitrogen_values = nitrogen_emissions.map(d => Number(d['Nitrogen (kgN / t edible weight)']))
            phos_values = phos_emissions.map(d => Number(d['Phosphorous (kgP / t edible weight)']))

            leftAxisScale1 = d3.scaleBand().domain(species).range([chartHeight1, 0]).padding(0.05);

            barvalueExtent1 = d3.extent(water_values)
            barScale1 = d3.scaleLinear().domain([0, barvalueExtent1[1]]).range([0, chartWidth1]);
            console.log('barscale1')
            console.log(barScale1)

            let leftAxis1 = d3.axisLeft();
            let leftAxisG1 = annotations1.append("g")
                .attr("class", "y-axis")
                // .attr("opacity", 0)
                .attr("transform", `translate(${margin1.left - 1}, ${margin1.top})`);
            leftAxis1.scale(leftAxisScale1);
            leftAxisG1.transition().call(leftAxis1);

            let bottomAxis1 = d3.axisBottom();
            let bottomAxisG1 = annotations1.append("g")
                .attr("class", "x-axis")
                // .attr("opacity", 0)
                .attr("transform", `translate(${margin1.left - 1},${chartHeight1 + margin1.top})`)

            bottomAxis1.scale(barScale1);
            bottomAxisG1.transition().call(bottomAxis1);

            //making scales and axes for land
            barvalueExtent2 = d3.extent(land_values)
            barScale2 = d3.scaleLinear().domain([0, barvalueExtent2[1]]).range([0, chartWidth1]);

            //making scales and axes for nitrogen
            barvalueExtent3 = d3.extent(nitrogen_values)
            barScale3 = d3.scaleLinear().domain([0, barvalueExtent3[1]]).range([0, chartWidth1]);

            //making scales for phos
            barvalueExtent4 = d3.extent(phos_values)
            barScale4 = d3.scaleLinear().domain([0, barvalueExtent4[1]]).range([0, chartWidth1]);
        }


        function drawInitial() {

            // createScales()
            drawChart(land_use, barScale2, leftAxisScale1, 'Land use (m2 / kg edible weight)')



        }

        function draw2() {
            drawChart(nitrogen_emissions, barScale3, leftAxisScale1, 'Nitrogen (kgN / t edible weight)')
        }

        function draw3() {
            drawChart(phos_emissions, barScale4, leftAxisScale1, 'Phosphorous (kgP / t edible weight)')
        }

        // function fakeChart() {
        //     createScales()
        //     // drawChart(land_use, barScale2, leftAxisScale1, 'Land use (m2 / kg edible weight)')
        // }

        function drawChart(data, barscale, leftaxisscale, column) {
            console.log('executed')

            chartArea1.selectAll('rect.bar').data(data)
                .join(enter => enter.append('rect')
                    .attr('class', 'bar')
                    // .attr("fill", barChartColor(input_mbti))
                    .attr("x", d => barscale(0))
                    .attr("y", d => leftaxisscale(d.Entity.split('(')[0].substr(0, d.Entity.split('(')[0].length - 1)))
                    .attr("height", leftaxisscale.bandwidth())
                    .attr("width", d => barscale(Number(d[column])) - barscale(0))
                    .attr("opacity", 0)
                    .call(enter => enter.transition()
                        .attr('opacity', 1)),
                    update => update.call(update => update.transition()
                        // .attr("fill", barChartColor(input_mbti))
                        .attr("x", d => barscale(0))
                        .attr("y", d => leftaxisscale(d.Entity.split('(')[0].substr(0, d.Entity.split('(')[0].length - 1)))
                        .attr("height", leftaxisscale.bandwidth())
                        .attr("width", d => barscale(Number(d[column])) - barscale(0))),
                    exit => exit.call(exit => exit.transition().attr('opacity', 0).remove()));
        }

        }

        getData();
    </script>
</body>

</html>